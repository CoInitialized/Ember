#include <stdio.h>
#include <unistd.h>
#include <time.h>
#include <string.h>
#include <stdlib.h>
#include "pvm3.h"

#define size_packet 2

void rodzic()
{
    struct pvmhostinfo *hostp;
    int result, check, i, ilhost, ilarch, tid, tidmaster;
    char bufor[64];

    gethostname(bufor, 20);
    printf("Rodzic: %s\n", bufor);
    if(tidmaster=pvm_mytid() <0) {
        pvm_perror("enroll");
        exit(1);
    }


    // TUTAJ ZACZYNA SIE PROGRAM

    pvm_config(&ilhost, &ilarch, &hostp);
    printf("Hosty PVM\n");
    printf("Ilosc hostow %d\n", ilhost); 
   // WIADOMOSC DO ZAKODOWANIA
    char wiadomosc [11] = "BCDEFGHIJK";
    // WIADOMOSC ZAKODOWANA
    char zakodowana [11];
    for  (int i = 0; i < 11; i++)
        zakodowana[i] = '\0';

    // INT TRZYMAJACY START INDEKS W STRINGU DO NASTEPNEJ PACZKI
    int index = 0;
    int string_length = strlen(wiadomosc);
    int odd = string_length % 2;

    printf("Dlugosc tekstu do zakodowania %d\n", string_length);

    // JESLI WIADOMOSC MA NIEPARZYSTA ILOSC ZNAKOW TO BEDZIE TRZEBA ZROBIC WYSYLKE TEJ RESZTKI NA KONCU Z MNIEJSZYM ARRAYEM

    
    // POCZATKOWA PETLA PO HOSTACH, WYSYLANIE IM KAWALKOW
    for(i=0; i<ilhost; i++)
    {
        printf("\t%s\n", hostp[i].hi_name);
        check=pvm_spawn("/home/pvm/pvm3/lab/example", 0, PvmTaskHost, hostp[i].hi_name, 1, &tid);
        if(!check)
            printf("Błąd powołania potomka do życia na %s\n", hostp[i].hi_name);
        // ARRAY NA KAWALEK
        char part_array[size_packet];

        // zapisywanie kawalka wiadomosci do zakodowania
        for (int i = index; i < index + size_packet; i++)
            part_array[i] = wiadomosc[i];

        pvm_initsend(PvmDataDefault);
		pvm_pkbyte(part_array,size_packet, sizeof(char));
        pvm_pkint(&index,1,1);
		pvm_send(tid, 200);

        // zwiekszamy indeks na zdaniu do zakodowania
        index += size_packet;
    }
    // KONIEC WYSYLANIA PIERWSZEJ SERII DO WSZYSTKICH HOSTOW

    printf("Odbieranie od potomka\n");
    result = 0;

    // ZCZYTYWANIE ZAKODOWANYCH I ROBIENIE NOWYCH POTOMKOW NA KOLEJNE KAWALKI
    do
    {
        pvm_recv(-1, 150);
        int cur_index;
        char zakodowany_kawalek[size_packet];
        pvm_upkbyte(zakodowany_kawalek, size_packet, sizeof(char));
        pvm_upkint(&cur_index,1,1);
        for (int i = cur_index; i < cur_index + size_packet; i++)
             zakodowana[i] = zakodowany_kawalek[i - cur_index];
        char do_printa[size_packet + 1];
        for (int i = 0; i < size_packet; i++)
            do_printa[i] = zakodowany_kawalek[i];
        do_printa[size_packet] = '\0';
        printf("%s\n", do_printa);
        
        if (index < (string_length - 4))
        {
	    check=pvm_spawn("/home/pvm/pvm3/lab/example", 0, PvmTaskHost, hostp[0].hi_name, 1, &tid);
	    if(!check)
	        printf("Błąd powołania potomka do życia na %s\n", hostp[i].hi_name);
            
            char part_array[size_packet];
            
            // zapisywanie kawalka wiadomosci do zakodowania
            for (int i = index; i < index + size_packet; i++)
                part_array[i] = wiadomosc[i];
	
	    pvm_initsend(PvmDataDefault);
            pvm_pkbyte(part_array,size_packet, sizeof(char));
            pvm_pkint(&index,1,1);
	    pvm_pkint(&tid,1,1);
            pvm_send(tid, 200);

	    index += size_packet;
	}

    }while(index < (string_length - 4));
    printf("Zakodowana wiadomosc: %s\n", zakodowana);
    pvm_exit();
}
void potomek()
{
    char do_zakodowania[size_packet];
    int ptid, index;
    ptid=pvm_parent();

    pvm_recv(-1,200);
    pvm_upkbyte(do_zakodowania, size_packet, sizeof(char));
    pvm_upkint(&index, 1,1);

    // TUTAJ JEST ROBIONY CEZAR

    for (int i = 0; i < size_packet; i++)
        do_zakodowania[i] = (char)(do_zakodowania[i] - 1);

    ///////////////////////////

    pvm_initsend(PvmDataDefault); 
    pvm_pkbyte(do_zakodowania,size_packet, sizeof(char));
    pvm_pkint(&index, 1,1);
    pvm_send(ptid, 150);
    pvm_exit();
}
main()
{
    if(pvm_parent() == PvmNoParent)
        rodzic();
    else
        potomek();
}
